---
title: "Simulation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Simulation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This page will introduce some of the core functions and how to use them for the simulation. This follows the `simulation.R` file and makes some sense out of it.

## Models 

The first thing to understand are the models, which are defined in `model.R`. These S4 classes define all models that we use in our simulation study. A model consists of a set of parameters and a within-person standard deviation, which can be provided values through the attributes `parameters` and `sd`. For example, creating a linear model and calling it `my_model`, we get:

```{r}
my_model <- paramrel::linear(
    parameters = c(10, 5),
    sd = 2
)
my_model
```

In this piece of code, the intercept is given the value `10` and the slope for _x_ is given the value `5`. You can retrieve the parameters through calling its attributes: 

```{r}
my_model@parameters 
my_model@sd
```

You can also change the values of the parameters through these same attributes:

```{r}
my_model@parameters <- c(-10, -5)
my_model@sd <- 0.5

my_model@parameters 
my_model@sd
```

Note that to initialize a model, you do not necessarily have to specify the arguments:

```{r}
my_model <- paramrel::linear()

my_model@parameters 
my_model@sd
```

Instead, the default parameter settings are used.



## Parameter generation 

The primary function to use for generating parameters is `parameter_grid`, which will create a given number of parameter sets for a particular model. Using this function only requires passing down the model you are interested in. For example, for the linear model, we can do:

```{r}
my_model <- paramrel::linear()

params <- paramrel::parameter_grid(my_model)
head(params)
```

The output of this function is a matrix of size $n \times k$, where $n$ is the number of parameter sets that have been generated and $k$ represents the number of parameters in the model. In this case, we get a $25 \times 2$ matrix.

Through additional arguments, we can control the parameter generation process. Specifically, one can change the number of parameter sets that are being generated, the process that is used for the generation of the parameters, and the bounds of the parameters. Focusing first on the number of parameters that are generated, one can change the values of `n_int` and `n_slope`, respectively denoting the number of different intercepts and slopes one wants to generate. For example:

```{r}
params <- paramrel::parameter_grid(
    my_model,
    n_int = 10, 
    n_slope = 10
)
head(params)

params <- paramrel::parameter_grid(
    my_model,
    n_int = 20, 
    n_slope = 20
)
head(params)
```

The first piece of code results in a $100 \times 2$ matrix while the second piece of code results in a $400 \times 2$ matrix. How do we get to these values? By default, the function `parameter_grid` will sample parameter values in an ordered manner within specified bounds of the parameters. The argument `n_int` and `n_slope` then define the number of unique, equally spaced values you wish to sample within this interval, where `n_int` controls this number of intercept parameters and `n_slope` for the slope parameters. 

While this type of simulation allows for a well-controlled simulation study, it may lack some generalizability across different simulation studies when the number of unique parameters differs greatly. We therefore allow for another type of parameter generation process through specifying the argument `n`, for example:

```{r}
params <- paramrel::parameter_grid(
    my_model,
    n = 100
)
head(params)
```

This will output a $100 \times k$ parameter matrix, no matter which model you provide to the function. In other words, you will always end up with 100 unique parameter sets. The way in which we achieve this is through uniform sampling across the bounds of the parameters. This does not guarantee that the parameters cover the entire possible range, but it gains in generalizability across different models in the simulation.

Finally, you can change the bounds of the intercepts and slopes through the `intercept` and `slope` parameters, where you provide a minimum and maximum value for the parameter. For example:

```{r}
params <- paramrel::parameter_grid(
    my_model,
    n = 10,
    intercept = c(-1, 1),
    slope = c(-1, 1)
)
head(params)

params <- paramrel::parameter_grid(
    my_model,
    n = 10,
    intercept = c(-100, 100),
    slope = c(-50, 50)
)
head(params)
```



## Running a simulation 

The heavy lifting for running a simulation is done by the `execute_study` function. At minimum, this function requires a generative and an estimation model to be defined, so that you can call:

```{r, eval = FALSE}
sim_model <- paramrel::linear()
est_model <- paramrel::quadratic()

paramrel::execute_study(
    sim_model, 
    est_model
)
```

The most important arguments that you can change in this function are the following:

- `n_participants`, `n_outcomes`, `n_bins`: Integers denoting the number of participants in the study and the number of bins and outcomes per bin to include in the experiment.
- `parameter_sd`: Numeric denoting the standard deviation on the parameters across participants (i.e., individual differences).
- `ICC`: Numeric between 0 and 1 denoting the ICC you wish to simulate, pitting between-subject differences against within-person differences.
- `statistics`: Named list containing functions that compute the statistics of interest (see `statistics.R` for more details).

Through changing the values of the arguments, we can run a small simulation study as:

```{r}
sim_model <- paramrel::linear()
est_model <- paramrel::quadratic()

paramrel::execute_study(
    sim_model, 
    est_model,
    n_participants = 10, 
    n_outcomes = 15, 
    n_bins = 5, 
    ICC = 0.8,
    statistics = list(
        "icc" = paramrel::icc, 
        "signal" = paramrel::signal
    )
)
```

The output of this function is a named list containing the output of the functions provided to `statistics`. These serve as our primary unit of analysis.
